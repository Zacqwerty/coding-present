/*
                                              ▓▓                                          
                                            ▓▓▓▓▓▓                                        
                                        ▓▓▓▓░░░░▓▓                                        
    ▓▓▓▓▓▓▓▓▓▓                        ▓▓░░  ░░▓▓░░▓▓▓▓                        ▓▓▓▓▓▓      
      ▓▓░░▓▓░░▓▓▓▓▓▓▓▓▓▓▓▓            ▓▓▓▓      ▓▓░░░░▓▓            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓        
        ▓▓░░░░░░░░▓▓▓▓░░░░▓▓▓▓░░░░  ▓▓▓▓▓▓  ░░░░  ▓▓▒▒  ░░    ▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▓▓▓▓        
        ▒▒▒▒░░▒▒░░▒▒▒▒░░▒▒▒▒▒▒      ░░▒▒░░        ▒▒░░      ▒▒▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒▒▒▒        
          ▒▒░░▒▒▒▒░░░░░░▒▒▒▒▒▒        ░░          ▒▒        ▒▒▒▒░░░░▒▒░░▒▒▒▒▒▒░░▓▓        
          ▓▓░░░░▓▓▓▓        ▓▓░░            ░░              ░░░░░░░░▓▓░░▓▓░░░░░░▓▓        
          ▓▓▒▒░░░░▓▓▓▓          ░░    ░░    ░░░░            ░░        ▒▒▓▓▓▓░░▓▓          
          ▓▓▒▒▒▒▒▒▒▒▓▓░░  ░░░░  ░░░░░░░░░░░░░░░░    ░░░░░░░░░░░░░░▒▒▒▒▓▓▒▒▒▒░░▓▓          
          ▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒      ░░░░░░░░░░░░░░░░  ░░░░░░░░░░      ░░░░░░░░░░▒▒▒▒          
          ▒▒░░░░░░░░░░░░▒▒  ░░    ░░░░░░░░▓▓░░▓▓  ░░░░░░░░            ░░░░░░▒▒░░          
          ░░▒▒░░        ░░░░░░░░░░  ░░░░▓▓▓▓▓▓▓▓▓▓░░░░░░░░          ▒▒▒▒░░▒▒░░            
            ░░▒▒░░░░    ░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓░░        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒        
                ▓▓░░░░          ██▓▓██████▓▓▓▓▓▓████▓▓████      ░░░░░░░░  ░░░░▓▓▓▓        
                ░░    ░░░░░░░░██▓▓████▓▓▓▓▓▓▓▓▓▓▓▓████▓▓████░░░░░░    ░░░░  ░░░░▓▓▓▓▓▓    
                            ░░▓▓████▓▓██████████▓▓▓▓████▓▓░░              ▓▓░░▒▒░░▓▓▓▓▓▓▓▓
                              ░░████▓▓████████████▓▓▓▓██▓▓                    ▓▓▓▓░░▓▓▓▓  
                    ░░░░░░░░▓▓▓▓▓▓▒▒████████▓▓██▓▓▒▒▒▒▓▓▓▓░░░░░░░░        ░░▒▒▒▒▒▒▒▒▒▒░░  
        ▒▒░░░░░░░░░░░░░░░░░░▒▒██▓▓▓▓▓▓▓▓██████████▓▓▓▓████░░░░░░░░░░░░░░░░▒▒▓▓▒▒▒▒▓▓░░    
      ▒▒░░░░░░  ░░░░  ░░  ░░░░▓▓▒▒▒▒▓▓██████████▓▓▒▒▓▓▓▓▓▓        ░░  ░░  ░░░░░░▒▒▒▒      
    ▓▓░░                      ██▓▓██▓▓██████████▓▓██▓▓▓▓████░░░░░░      ▓▓▓▓░░▓▓▓▓        
    ▓▓      ▓▓                ████▓▓██████████▓▓██▓▓▓▓▓▓██    ░░  ░░▓▓▓▓▓▓▓▓▓▓            
  ▒▒░░▒▒▒▒░░▒▒▒▒▒▒            ░░██▒▒▒▒▓▓▓▓▒▒▓▓▓▓▒▒▓▓▒▒▓▓░░        ░░  ░░▒▒                
▓▓▓▓▓▓░░░░▓▓░░                ████████▓▓██▓▓██▓▓██▓▓██████          ░░                    
    ▓▓▓▓░░░░              ░░░░░░████▓▓▓▓▓▓▓▓▓▓▓▓▓▓████  ░░░░░░░░                          
        ▓▓▓▓            ░░░░      ████████▓▓██▓▓██  ░░░░    ░░      ▓▓                    
                  ░░░░░░░░      ░░░░░░░░░░      ░░      ░░    ░░░░░░▒▒▒▒                  
            ▓▓░░░░▓▓░░          ░░        ░░    ░░░░      ░░          ▓▓▓▓                
          ▓▓░░░░▓▓░░          ░░          ░░░░      ░░      ▓▓░░        ▓▓▓▓              
          ▓▓░░▓▓░░              ░░          ░░      ░░      ▓▓░░▓▓░░░░░░░░▓▓              
        ▓▓▓▓░░▓▓▓▓                                    ░░      ▓▓▓▓░░░░░░░░▓▓              
        ▓▓░░▓▓░░▓▓        ▓▓                          ░░        ▓▓▓▓░░▓▓░░░░▓▓            
        ▓▓░░░░▓▓▓▓    ▓▓▓▓▓▓                            ░░      ░░▓▓▓▓▓▓▓▓░░▓▓            
        ▓▓░░▓▓▓▓▓▓▓▓▓▓▓▓░░▓▓    ▓▓              ░░      ▓▓░░░░▓▓▓▓░░░░░░░░▓▓▓▓            
        ▓▓▓▓░░▓▓░░░░▓▓▓▓▓▓░░  ▓▓▓▓    ▓▓      ▓▓▒▒▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░▓▓▓▓            
        ░░▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  ▒▒▒▒░░  ▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒░░            
        ▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒░░▒▒▒▒▒▒  ▒▒▒▒░░░░░░▒▒░░▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒              
        ▓▓░░▒▒▒▒▓▓▓▓▓▓▒▒░░░░▒▒▓▓░░░░▓▓▓▓      ▓▓▓▓░░░░░░▓▓░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓              
      ▓▓▓▓▓▓          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓          ▓▓▓▓▓▓▓▓▓▓░░▒▒░░░░▓▓░░▓▓░░▓▓              
      ▒▒░░░░          ░░░░  ░░  ░░░░░░          ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒░░▒▒░░▒▒▒▒            
      ░░                                          ░░    ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒            
                                                                ▓▓▓▓▓▓▓▓▓▓▓▓▓▓            
                                                                          ▓▓▓▓▓▓          
--------------------------------------------------------------------------------------
                        YOU ARE THE SUNSHINE TO MY WORLD
--------------------------------------------------------------------------------------
*/


//Canvas
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

//Paint
const paint = document.getElementById('paint');
const ptx = paint.getContext('2d', { willReadFrequently: true });

//Buffer
const buffer = document.getElementById("buffer");

//Other Document Elements
const textFill = document.getElementById('textFill');
const audio = document.getElementById('audio');

//Canvas Heights
paint.width = canvas.width = document.body.clientWidth;
paint.height = canvas.height = document.body.clientHeight;

//Const
const interval = 16.67;
const numFocalPoints = 1000;
const circlHatchMin = 350;

//System Var
var lastDeltaTimeStamp = Date.now();
var startTimeStamp = Date.now();
var deltaTime = 0;
var frameCount = 0;

var intervalText;

var phase = 0;

//Variables
var sunflower, sunOutline, midSunflower;
var imgMessage;

var winScale = Math.min(canvas.width, canvas.height);
var outlineSize = winScale * 1.1;
var flowerSize = winScale * 0.8;
var midFlowerSize = winScale * 0.08;
var flowerColor = 'rgba(255,221,0,1)';

var imgScale = 0;

var deltaSize = 0;
var scaleNum = 0;

var rotRate = 0.007;
var rotateAngle = 0;

var tweenNum = 0;
var isTweening = false;

//#region Hatching
var toggleHatch = true;
var hatchDelay = 1;
var hatchSize = 100;
var curHatchSize = 100
var hatching = {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
    scale: 0,
    imageData: null
}
var spacingX = canvas.width / (numFocalPoints + 1);
var spacingY = canvas.height / (numFocalPoints + 1);

var copyHatch = {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
    scale: 0,
    imageData: null
}

var focalArray = [];
//#endregion

//#region Message

var fontSize = '20px';
var fontFamily = 'Pixelify Sans'
var message = "This is a testing message only made for testing and testing only";
var currentText = "";

var messageBarSideColor;
var messageGradientBox;

var letterTick = 0.02;
var tickTimer = 0;
var curCount = -1;

var refImage;
var refDet = {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
    scale: 0
}

//#endregion

//Functions
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

const time = () => { return (Date.now() - startTimeStamp) / 1000 }

const distance = (ax, ay, bx, by) => Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));

function shiftString(str, shiftDirection) {
    return shiftDirection > 0 ? str.substring(1) + str.charAt(0) : str.charAt(str.length - 1) + str.substring(0, str.length - 1);
}

function tick() {
    const now = Date.now();
    deltaTime = (now - lastDeltaTimeStamp) / 1000;
    lastDeltaTimeStamp = now;
}

function percentageDiff(iW, iH, oW, oH) {
    let sW = oW / iW;
    let sH = oH / iH;

    return Math.min(sW, sH);
}

function easeInOutBounce(x) {
    return x < 0.5
        ? (1 - easeOutBounce(1 - 2 * x)) / 2
        : (1 + easeOutBounce(2 * x - 1)) / 2;
}

function easeOutBounce(x) {
    const n1 = 7.5625;
    const d1 = 2.75;

    if (x < 1 / d1) {
        return n1 * x * x;
    } else if (x < 2 / d1) {
        return n1 * (x -= 1.5 / d1) * x + 0.75;
    } else if (x < 2.5 / d1) {
        return n1 * (x -= 2.25 / d1) * x + 0.9375;
    } else {
        return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
}

async function awaitImage(src) {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.src = src;
        img.crossOrigin = "anonymous"
        img.onload = () => {
            const data = {
                image: img,
                loaded: true
            };
            resolve(data);
        }
        img.onerror = reject;
    })
}

function getImageData(image, w, h) {
    buffer.width = w;
    buffer.height = h;

    const bfr = buffer.getContext('2d', { willReadFrequently: true });

    //Clear before drawing
    bfr.clearRect(0, 0, w, h)

    //Draw image
    bfr.drawImage(image, 0, 0, w, h);

    const imgData = bfr.getImageData(0, 0, buffer.width, buffer.height);

    return imgData;
}

function getPixelData(imageData, x, y) {
    let index = ((y * imageData.width) + x) * 4;
    let r = imageData.data[index];
    let g = imageData.data[index + 1];
    let b = imageData.data[index + 2];
    let a = imageData.data[index + 3];

    return {
        r,
        g,
        b,
        a
    }
}

function drawTextOnArc(text, x, y, radius, startAngle, clockwise, kerning) {
    var len = text.length;
    var tm = ctx.measureText(text);
    var clockWise = clockwise ? 1 : -1;
    var textHeight = tm.fontBoundingBoxAscent;
    var diameter = 2 * radius + textHeight * 2
    var angle = startAngle;

    ctx.save();
    ctx.translate(x, y);
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';

    ctx.rotate(angle);
    for (var i = 0; i < len; i++) {
        var charWid = ctx.measureText(text[i]).width;
        ctx.rotate((charWid / 2) / (diameter / 2 - textHeight) * clockWise);
        ctx.fillText(text[i], 0, (1) * (0 - diameter / 2 + textHeight / 2));
        ctx.rotate((charWid / 2 + kerning) / (diameter / 2 - textHeight) * clockwise);
    }

    ctx.restore();
}

function circleHatch(hatch, x, y) {
    let hX = Math.floor(Math.random() * hatch.width);
    let hY = Math.floor(Math.random() * hatch.height);

    //Get and set Color
    let pixelColor = getPixelData(hatch.imageData, hX, hY);
    ptx.strokeStyle = 'rgba(' + pixelColor.r + ',' + pixelColor.g + ',' + pixelColor.b + ',' + pixelColor.a + ')';

    let r = distance(x, y, hX, hY);
    let theta = Math.atan((hY - y) / (hX - x));
    let hS = Math.min(circlHatchMin, curHatchSize / 10);
    let d = (Math.random() * ((Math.PI / (hS + 10)) - (Math.PI / hS))) + (Math.PI / hS);

    ptx.beginPath();

    if (x >= hX && y >= hY) {
        theta += Math.PI;
        ptx.arc(x, y, r, theta - d, theta + d);
    }

    if (x >= hX && y < hY) {
        theta -= Math.PI;
        ptx.arc(x, y, r, theta - d, theta + d);
    }

    if (x < hX && y <= hY) {
        ptx.arc(x, y, r, theta - d, theta + d);
    }

    if (x < hX && y > hY) {
        ptx.arc(x, y, r, theta - d, theta + d);
    }

    ptx.stroke();

    curHatchSize += 0.01;
}

function classicHatch(hatch) {
    let x = Math.floor(Math.random() * hatch.width);
    let y = Math.floor(Math.random() * hatch.height);

    let pixelColor = getPixelData(hatch.imageData, x, y);

    if (Math.random() < 0.999)
        ctx.strokeStyle = 'rgba(' + pixelColor.r + ',' + pixelColor.g + ',' + pixelColor.b + ',' + pixelColor.a + ')';
    else strokeStyle = 'black';

    let d = (Math.random() * (hatchSize / 2)) + (hatchSize / 2);

    let aCord = { x: clamp(x - d / 2, 0, hatch.width), y: clamp(y - d / 2, 0, hatch.height) };
    let bCord = { x: clamp(x + d / 2, 0, hatch.width), y: clamp(y + d / 2, 0, hatch.height) };


    ctx.beginPath();
    ctx.moveTo(aCord.x, aCord.y);
    ctx.lineTo(bCord.x, bCord.y);
    ctx.stroke();

    //crosshatch
    ctx.beginPath();
    ctx.moveTo(aCord.x, bCord.y);
    ctx.lineTo(bCord.x, aCord.y);
    ctx.stroke();
}

function arcHatch(hatch) {
    let x = Math.floor(Math.random() * hatch.width);
    let y = Math.floor(Math.random() * hatch.height);

    let pixelColor = getPixelData(hatch.imageData, x, y);
    ctx.strokeStyle = 'rgba(' + pixelColor.r + ',' + pixelColor.g + ',' + pixelColor.b + ',' + pixelColor.a + ')';

    let startAngle = Math.random() * (Math.PI * 2);
    let endAngle = (Math.random() * (Math.PI / 2)) + startAngle / 2;
    let radius = Math.random() * Math.PI;
    let midAngle = ((startAngle + endAngle) / 2) - Math.PI;
    let midPoint = { x: (x + (radius * Math.cos(midAngle))), y: (y + (radius * Math.sin(midAngle))) };


    ctx.beginPath();
    ctx.arc(midPoint.x, midPoint.y, radius, startAngle, midAngle);
    ctx.stroke();

}

function randomHatch(hatch) {
    let x = Math.floor(Math.random() * hatch.width);
    let y = Math.floor(Math.random() * hatch.height);

    let pixelColor = getPixelData(hatch.imageData, x, y);

    ctx.strokeStyle = 'rgba(' + pixelColor.r + ',' + pixelColor.g + ',' + pixelColor.b + ',' + pixelColor.a + ')';

    let d = (Math.random() * (hatchSize / 2)) + (hatchSize / 2);

    ctx.beginPath();
    ctx.moveTo(x - 3, y);
    ctx.lineTo(Math.floor(Math.random() * hatch.width), Math.floor(Math.random() * hatch.height));
    ctx.stroke();


    /*
    let r = Math.random() * 10;
    let shape = Math.random();

    if (shape < 0.3) {
        ctx.fillRect(hX, hY, Math.random() * r, Math.random() * r * 2);
    } else if (shape < 0.6) {
        ctx.beginPath();
        ctx.rect(hX, hY, Math.random() * r * 2, Math.random() * r)
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(hX, hY, Math.random() * r, Math.random() * Math.PI, (Math.random() * Math.PI) + Math.PI)
        ctx.stroke();
    }
    */
}

function fragmentText(text, maxWidth) {
    var words = text.split(' '),
        lines = [],
        line = "";

    if (ctx.measureText(text).width < maxWidth) {
        return [text];
    }

    while (words.length > 0) {
        while (ctx.measureText(words[0]).width >= maxWidth) {
            var tmp = words[0];
            words[0] = tmp.slice(0, -1);

            if (words.length > 1) {
                words[1] = tmp.slice(-1) + words[1];
            } else {
                words.push(tmp.slice(-1));
            }
        }

        if (ctx.measureText(line + words[0]).width < maxWidth) {
            line += words.shift() + " ";
        } else {
            lines.push(line);
            line = "";
        }
        if (words.length === 0) {
            lines.push(line);
        }
    }
    return lines;
}

function roundRect(x, y, width, height, radius = 15) {
    if (width < 2 * radius) radius = width / 2
    if (height < 2 * radius) radius = height / 2

    //Draw Round Rect
    ctx.moveTo(x + radius, y)
    ctx.arcTo(x + width, y, x + width, y + height, radius);
    ctx.arcTo(x + width, y + height, x, y + height, radius);
    ctx.arcTo(x, y + height, x, y, radius);
    ctx.arcTo(x, y, x + width, y, radius);
}


//Init
function init() {
    EventManager.init();

    setup();
    callBackSetup();

    for (let i = 0; i < 1000; i++) {
        textFill.textContent += str;
    }

    //Shift
    intervalText = setInterval(() => {
        textFill.textContent = '';
        for (let i = 0; i < 1000; i++) {
            textFill.textContent += str;
        }

        str = shiftString(str, -1);
    }, 500)

    setInterval(tick, interval);

    update();
}

//Setup
function setup() {
    audio.volume = 0.5;

    awaitImage('./img/sunflower.png').then(value => {
        if (value?.loaded) {
            sunflower = value;
        }
    })

    awaitImage('./img/sunoutline.png').then(value => {
        if (value?.loaded) {
            sunOutline = value;
        }
    })

    awaitImage('./img/sunflower3.png').then(value => {
        if (value?.loaded) {
            midSunflower = value;
        }
    })

    awaitImage('https://th.bing.com/th/id/OIP.ElBsMmgtLU7X4lQV8vPowQHaKe?rs=1&pid=ImgDetMain').then(value => {
        if (value?.loaded) {
            imgMessage = value;

            //Init phase 2 variables
            refDet.scale = imgScale = percentageDiff(imgMessage.image.width, imgMessage.image.height, paint.width * 0.95, paint.height * 0.95);

            refDet.x = hatching.x = (paint.width / 2) - ((imgMessage.image.width * imgScale) / 2);
            refDet.y = hatching.y = (paint.height / 2) - ((imgMessage.image.height * imgScale) / 2);
            refDet.width = hatching.width = Math.floor((imgMessage.image.width * imgScale));
            refDet.height = hatching.height = Math.floor((imgMessage.image.height * imgScale));
            hatching.scale = imgScale;

            spacingX = hatching.width / (numFocalPoints + 1);
            spacingY = hatching.height / (numFocalPoints + 1);

            hatching.imageData = getImageData(value.image, hatching.width, hatching.height);

            for (let i = 0; i <= numFocalPoints; i++) {
                const fPoint = { x: i * spacingX, y: i * spacingY }
                focalArray.push(fPoint);
            }
        }
    })

    //Preload first image
    awaitImage(sun.flower[0].image).then(value => {
        copyHatch.scale = percentageDiff(value.image.width, value.image.height, paint.width * 0.95, paint.height * 0.95);

        copyHatch.x = (paint.width / 2) - ((value.image.width * imgScale) / 2);
        copyHatch.y = (paint.height / 2) - ((value.image.height * imgScale) / 2);
        copyHatch.width = Math.floor((value.image.width * imgScale));
        copyHatch.height = Math.floor((value.image.height * imgScale));
        copyHatch.scale = imgScale;

        spacingX = copyHatch.width / (numFocalPoints + 1);
        spacingY = copyHatch.height / (numFocalPoints + 1);

        copyHatch.imageData = getImageData(value.image, copyHatch.width, copyHatch.height);
    })


    textFill.style.fontSize = `${Math.min(canvas.width, canvas.height)/56}px`;
    textFill.style.letterSpacing = `${Math.min(canvas.width, canvas.height)/56}px`;
}

function callBackSetup() {
    EventManager.instance.make('next-phase', () => {
        clearInterval(intervalText);
        textFill.textContent = '';

        phase = 1;
        tweenNum = 0;

        EventManager.instance.emit('next-line');

        ctx.lineWidth = 0.8;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        isTweening = false;
        scaleNum = easeInOutBounce(tweenNum);
        deltaSize = (Math.max(canvas.width, canvas.height) * scaleNum);

        //Setup Gradient
        let offset = hatching.width * 0.1;
        messageGradientBox = ctx.createLinearGradient(hatching.x, canvas.height - ((hatching.width * 0.9) / 3) - (offset / 4), hatching.x, canvas.height - (offset / 4));
        messageGradientBox.addColorStop(0, 'rgb(144, 111, 80, 0.75)');
        messageGradientBox.addColorStop(1, 'rgb(91, 33, 11, 0.75)');

        //Play Audio
        audio.play();

        ctx.globalAlpha = 0;
        ctx.letterSpacing = '2px';
    }, false);

    EventManager.instance.make('next-line', () => {
        petalCount++;
        
        hatching = copyHatch;

        awaitImage(sun.flower[Math.min(sun.flower.length - 1, petalCount)].image).then(value => {
            copyHatch.scale = percentageDiff(value.image.width, value.image.height, paint.width * 0.95, paint.height * 0.95);

            copyHatch.x = (paint.width / 2) - ((value.image.width * copyHatch.scale) / 2);
            copyHatch.y = (paint.height / 2) - ((value.image.height * copyHatch.scale) / 2);
            copyHatch.width = Math.floor((value.image.width * copyHatch.scale));
            copyHatch.height = Math.floor((value.image.height * copyHatch.scale));

            spacingX = copyHatch.width / (numFocalPoints + 1);
            spacingY = copyHatch.height / (numFocalPoints + 1);

            copyHatch.imageData = getImageData(value.image, copyHatch.width, copyHatch.height);
            weavesCount = 0;
            message = sun.flower[Math.min(sun.flower.length - 1, petalCount)].message[weavesCount];
            curCount = -1;

            ptx.clearRect(0, 0, canvas.width, canvas.height);
        })
    }, true);
}

//Update
function update() {
    //#region Logic
    frameCount++;

    rotateAngle += rotRate;

    rotateAngle = rotateAngle % 360;

    if (isTweening && tweenNum < 1) {
        tweenNum += 0.0167;
        tweenNum = clamp(tweenNum, 0, 1);
        scaleNum = easeInOutBounce(tweenNum);

        deltaSize = (Math.max(canvas.width, canvas.height) * scaleNum);
    } else if (isTweening && tweenNum >= 1) {
        EventManager.instance.emit('next-phase')
    }
    //#endregion

    //Drawing Aspect
    switch (phase) {
        case 0:
            sunflowersForHer();
            break;
        case 1:
            messageToHer();
            break;
    }

    //Refresh Animations
    requestAnimationFrame(update);
}

//Special Funct
function sunflowersForHer() {
    //#region Sunflower Intro
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();

    //Rotate
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.translate(canvas.width / 2, canvas.height / 2)
    ctx.rotate(rotateAngle);

    ctx.fillStyle = 'black';

    ctx.globalCompositeOperation = "destination-out";
    //ctx.globalCompositeOperation = "destination-in";

    if (sunOutline?.loaded) {
        ctx.drawImage(sunOutline.image, -((outlineSize + deltaSize) / 2), -((outlineSize + deltaSize) / 2), (outlineSize + deltaSize), (outlineSize + deltaSize));
    }

    ctx.restore();

    ctx.save()

    ctx.translate(canvas.width / 2, canvas.height / 2)
    ctx.rotate(-rotateAngle);

    if (sunflower?.loaded) {
        ctx.drawImage(sunflower.image, -((flowerSize + deltaSize) / 2), -((flowerSize + deltaSize) / 2), (flowerSize + deltaSize), (flowerSize + deltaSize));
    }

    ctx.globalCompositeOperation = "destination-in";

    ctx.fillRect(-canvas.width, -canvas.he, canvas.width, canvas.height);

    ctx.restore();

    ctx.globalCompositeOperation = "source-over";

    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, (winScale * 0.13) + deltaSize, 0, Math.PI * 2, false);
    ctx.fill();



    if (!isTweening) {
        ctx.save();

        ctx.translate(canvas.width / 2, canvas.height / 2)
        ctx.rotate(rotateAngle / 2);

        //Set Font settings
        let fSize = Math.min(canvas.width, canvas.height)/32;

        ctx.fillStyle = flowerColor;
        ctx.font = "bold " + fSize + "px Sunflower";
        drawTextOnArc('CLICK ME ALY', 0, 0, (winScale * 0.08), 0, true, 1);
        drawTextOnArc('CLICK ME ALY', 0, 0, (winScale * 0.08), 135, true, 1);

        ctx.strokeStyle = flowerColor;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(0, 0, (winScale * 0.13), 0, Math.PI * 2, false);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(0, 0, (winScale * 0.05), 0, Math.PI * 2, false);
        ctx.fill();

        ctx.restore();

        ctx.save();

        ctx.translate(canvas.width / 2, canvas.height / 2)
        ctx.rotate(-rotateAngle / 2);

        if (midSunflower?.loaded) {
            ctx.drawImage(midSunflower.image, -(midFlowerSize / 2), -(midFlowerSize / 2), midFlowerSize, midFlowerSize);
        }

        ctx.restore();
    }

    ctx.globalCompositeOperation = "source-over";
    //#endregion

}

function messageToHer() {
    if (imgMessage?.loaded) {
        if (toggleHatch) {
            ptx.save();

            ptx.lineWidth = Math.PI;

            ptx.translate(hatching.x, hatching.y);

            ptx.rect(0, 0, hatching.width, hatching.height);
            ptx.clip();

            if (frameCount % hatchDelay === 0) {
                for (let i = 0; i < 10; i++) {
                    for (let j = 0; j < focalArray.length; j++) {
                        circleHatch(hatching, focalArray[j].x, focalArray[j].y);
                    }
                }
            }


            ptx.restore();

        }

        if (curHatchSize > 5000) {
            if (ctx.globalAlpha < 1) {
                ctx.globalAlpha = clamp(ctx.globalAlpha + (deltaTime/3), 0, 1);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            //Box drawing
            let mWidth = refDet.width * 0.9;
            let mHeight = (refDet.width * 0.9) / 3;
            let offset = refDet.width - mWidth;

            ctx.save();
            ctx.fillStyle = messageGradientBox;
            ctx.beginPath();
            roundRect(refDet.x + offset / 2, canvas.height - mHeight - (offset / 4), mWidth, mHeight, 15);
            ctx.fill();

            ctx.restore();

            //Yellow Outline
            ctx.save();
            ctx.shadowColor = "black";
            ctx.shadowBlur = 10;

            ctx.strokeStyle = 'rgba(255,221,0,1)';
            ctx.lineWidth = 5;
            ctx.beginPath();
            roundRect(refDet.x + offset / 2, canvas.height - mHeight - (offset / 4), mWidth, mHeight, 15);
            ctx.stroke();

            ctx.restore();

            //Text stuff here

            if (curCount >= 0) {
                let lines  = fragmentText(currentText, mWidth * 0.9);

                fontSize = `${mWidth/32}px`;
                ctx.font = fontSize + ' ' + fontFamily;

                ctx.lineWidth = Math.PI;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'white';
                
                lines.forEach((l, i) => {
                    ctx.strokeText(l, refDet.x + (mWidth * 0.1), canvas.height - mHeight + (i * parseInt(fontSize, 0)) + (parseInt(fontSize, 0)))
                    ctx.fillText(l, refDet.x + (mWidth * 0.1), canvas.height - mHeight + (i * parseInt(fontSize, 0)) + (parseInt(fontSize, 0)))
                });
                    
            }

            //Do the thing;
            if (letterTick < tickTimer && ctx.globalAlpha == 1) {
                tickTimer = 0;

                curCount++;
                if (message[curCount] == ' ') curCount++;

                currentText = message.substring(0, Math.min(curCount, message.length));
            }

            tickTimer += deltaTime;
        }
    }
}

//Events
onmousedown = () => {
    isTweening = true;

    if (phase == 1 && curCount >= message.length) {

        if (petalCount < sun.flower.length - 1 && weavesCount + 1 >= sun.flower[petalCount].message.length) {
            EventManager.instance.emit('next-line');
        }

        if (weavesCount < sun.flower[petalCount].message.length - 1) {
            weavesCount++;
            message = sun.flower[petalCount].message[weavesCount];
            curCount = -1;
        }
    }
}


//Start function
init();